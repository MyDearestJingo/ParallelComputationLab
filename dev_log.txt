@Before Apr 29nd
= 已完成
- 矩阵运算中基础部分，多线程部分，矩阵行读优化部分的编写并通过调试运行，已获取运行结果

@Apr 29nd
= 问题
- 编译失败
    - 可能原因：GCC编译选项问题，未能正常启动SIMD(SSE/AVX)

@Apr 30nd
= 发现
- GCC编译选项可使用-msse（使用SSE），其他选项可见https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/i386-and-x86_002d64-Options.html
- CMAKE选项则可以使用SET(CMAEK_CXX_FLAGS)或SET(CMAKE_C_FLAGS)，也可直接通过ADD_COMPILE_OPTIONS命令
= 待办
- 将SIMD加速代码独立，简化程序和CMakeLists.txt文件编写，先确保可正常使用SIMD再作其他整合的操作
    - Apr 30nd 17:50 已不用此工作，先已经可以编译运行
= 草他妈的！！！！！！！
- 一定要注意vl2_matrix.cpp/matrixF32_madd()里底层循环的ap++，很重要！坑了老子一下午！
= 已完成
- 对simd_arch.h的自定义，也就是注释掉/取消注释一部分宏，以启用接口
- CMake编写并调试运行，现已可运行
= 下一阶段
- 编写matrix_madd()函数外部（在case SSE）中的外层循环，以更新传入的指针基址

@May 1st 3:00
= 已完成
- 编写matrix_madd()函数外部（在case SSE）中的外层循环，更新传入的指针基址
= 可优化点
- 在计算idx_（即idxA,idxB,idxC）时可考虑使用SSE来进行加速
- 直接使用OpenMP进行多线程会出现整合问题，计算结果有误
    - 考虑手动划分16个线程进行运算，最后整合
= 习得技能
- 如果在case中声明了变量，需要用{}将这个case的内容括住
    - 养成习惯，写case的话都要带{}
- CMake使用OpenMP
    - 1. 添加-fopenmp编译选项
    - 2. 添加FIND_PACKAGE(OpenMP REQUIRED)
    - 3. 添加TARGET_LINK_LIBRARIES(pclab_exe OPENMP::OPENMP_CXX)
= 代码缺陷：
- 提高_VF32_SIZE将会导致计算不充分，原因不明
= 待办
- 高优先级：完成AVX512的编写
- 低优先级：找到提高_VF32_SIZE且不会导致计算错误的办法
@May 1st 14:38
= 已完成
- AVX编写
    - 由于i5-8500与i7-9700均不支持AVX512，故目前暂时无法实现
= 发现
- 在使用AVX的过程中，如果在读主存时使用_mm256_load_ps((aAddr))将会出现段错误
    - 原因可能是内存不连续（但是不应该啊，申请内存的时候是连续申请的啊）
    - 验证方案：尝试改用C的malloc函数进行分配
    - 规避该问题：使用_mm256_loadu_ps((aAddr))进行代替
= 习得技能
- CMake enable AVX
    - 添加编译选项-mavx
@May 1st 16:00
= 已完成
- 矩阵分块编写和调试运行

@May 6nd 3:52
= 已完成
- radix_sort()的编写与调试运行
    - 输入参数：
        - *arr: 待排序数组的首地址
        - len: 待排序数组的长度
        - radix: 分桶的基数，当前为16，决定掩码单位长度
        - pos_len: 分桶的指数，当前为1，决定掩码总长度
        - buf_size： 应实验报告要求加入，现在作用尚未明确
- sort_gen()，也就是数组生成器生成的数组将会导出文件保存于./data/unsorted_*.dat文件中
- check()
    - 生成由qsort()函数排序后的数组test_arr，将会导出文件保存于./data/sorted_*.dat文件中；
    - 将输入的arr与test_arr进行对位检测；
    - 逐一检测arr前后元素的大小关系；
= 下一阶段
- 搞清楚buffer size的作用，获取实验数据
- 按照Chrome收藏夹里的多线程完成改写
@May 6th 16:56
= 已完成
- Cache Buffer机制现已加入肯德基豪华午餐
- 多线程机制现已加入肯德基豪华午餐（未完成，还差最后归并）
    - int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func) (void *), void *arg);的各种踩坑
        - func，也就是需要线程执行的函数的返回值必须是【void *】，也就是说，函数得是void *func()；
        - 对于func的参数传递，如果有多个参数需要传递给func，则先用一个结构体打包，然后再传
            指针（在pthread_create将会强制转换为void*)，到了func里再将传入的指针强制转换为结构体类型指针，之后操作便可；
- 取消radix_sort()参数radix, pos_len, buf_size；
@May 7th 00:07
= 踩坑警告
- 对于目前使用的多线程处理方案，调用堆栈为：pthread_creat()->thread_exec()->radix_sort()，由于向thread_exec()
    传参时使用指针传参（参数结构体），进而导致在thread_exec()将参数处理完并传入radix_sort()之前，pthread_creat()再次启用
    新线程并调用thread_exec()并传入与之前相同的指针，且指针指向的结构体内的值由于前者正在使用而未能及时更新值，故而导致多个
    线程使用相同的参数调用thread_exec()和radix_sort()，导致运算错误
        - 解决方案：不再使用同一个参数结构体初始化线程，每个线程使用不同的参数结构体；
= 已完成
- 多线程radix_sort()已经可以完成基本功能
    - 注意，THREAD_NUM必须能够被N整除，否则会出事
    - radix_sort()后的归并过程目前是性能瓶颈（当前为THRAD_NUM路，单线程归并）
= IDEA
- 矩阵的BLOCK+多线程，SSE+多线程等，计划改用固定C框，移动A、B框来实现并行，由此每个线程都能完成C中一个BLOCK的完整计算而无需
    依赖其他线程的运算结果；